---
title: "Single cell resolution landscape of equine peripheral blood mononuclear cells reveals diverse cell types including T-bet+ B cells."
author: "Roosheel Patel*, Joy E. Tomlinson*, Thomas J. Divers, Gerlinde R. Van de Walle, Brad Rosenberg, "
date: "11/23/2020"
output: html_document
---


```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  message = FALSE,
  echo = FALSE,
  comment = "#>",
  fig.path = "../figures//",
  dpi = 600
)
```

## Abstract
  Traditional laboratory model organisms represent a small fraction of the diversity of multicellular life, and findings in any given experimental model often do not translate to other species. Immunology research in non-traditional model organisms can be advantageous or even necessary (e.g. for host-pathogen interaction studies), but presents multiple challenges, many stemming from an incomplete understanding of potentially species-specific immune cell types, frequencies and phenotypes. Identifying and characterizing immune cells in such organisms is frequently limited by the availability of species-reactive immunophenotyping reagents for flow cytometry, and insufficient prior knowledge of cell type-defining markers. Here, we demonstrate the utility of single cell RNA sequencing (scRNA-Seq) to characterize immune cells for which traditional experimental tools are limited. Specifically, we used scRNA-Seq to comprehensively define the cellular diversity of equine peripheral blood mononuclear cells (PBMCs) from healthy horses across different breeds, ages, and sexes. We identified 30 cell type clusters partitioned into five major populations: Monocytes/Dendritic Cells, B cells, CD3+PRF1+ lymphocytes, CD3+PRF1- lymphocytes, and Basophils. Comparative analyses revealed many cell populations analogous to human PBMC, including transcriptionally heterogeneous monocytes and distinct dendritic cell subsets (cDC1, cDC2, plasmacytoid DC). Remarkably, we found that a majority of the equine peripheral B cell compartment is comprised of T-bet+ B cells; an immune cell subpopulation typically associated with chronic infection and inflammation in human and mouse.

**Objective: To identify and characterize the immune cell types in the horse peripheral blood using single cell RNA sequencing**

# Methods

## Sample collection
Approximately 50 mL of blood was collected from each horse by standard jugular venipuncture. Immediately following collection, PBMC were isolated by Ficoll gradient centrifugation, as previously described {Tomlinson JE, Wagner B, Felippe MJB, Van de Walle GR. Multispectral fluorescence-activated cell sorting of B and T cell subpopulations from equine peripheral blood. Veterinary Immunology and Immunopathology. 2018;199:22–31.}. Residual erythrocytes were removed by ammonium chloride lysis. All studies were conducted under approval of Cornell University Institutional Animal Care and Use Committee (#2014-0024). 

Within one hour of isolation, fresh PBMC were processed for scRNA-Seq on the 10X Genomics Chromium platform (10X Genomics). PBMC collection and scRNA-Seq were performed in three independent batches (Batch 1: Subject 1, Batch 2: Subject 3, Batch 3: Subjects 2,4,5,6,7). For each PBMC sample, 9000 cells were loaded to a single lane on the 10X Genomics Chromium instrument. scRNA-Seq libraries were prepared with the 10X Genomics Chromium Single Cell 3’ Reagent Kit (v2), according to manufacturer’s instructions. Libraries were pooled and sequenced on the Illumina NextSeq 500 in paired-end configuration (Read 1, cell barcode: 26 nt; Read 2, transcript: 98 nt) to a target read depth of approximately 35,000 paired-end reads per cell.

The EquCab3.0 reference genome {Kalbfleisch, T.S., Rice, E.S., DePriest, M.S. et al. Improved reference genome for the domestic horse increases assembly contiguity and composition. Commun Biol 1, 197 (2018). https://doi.org/10.1038/s42003-018-0199-z} was used in all analyses. Reference transcript annotations (Ensembl v95) were supplemented by manual annotation of the immunoglobulin heavy chain and light chain loci as described by {Wagner B. Immunoglobulins and immunoglobulin genes of the horse. Developmental & Comparative Immunology. 2006;30:155–64.}

## Read mapping and quantification

Reads were assigned to cell barcodes, mapped and quantified per gene using the CellRanger work flow (v 3.0.1, 10X Genomics) with default parameters (“standard workflow”). In our optimized work flow, BAM files generated by CellRanger were reformatted (appending cellular barcode and UMI sequence to alignment read names) and were input to the End Sequence Analysis Toolkit (ESAT, {Derr A, Yang C, Zilionis R, Sergushichev A, Blodgett DM, Redick S, et al. End Sequence Analysis Toolkit (ESAT) expands the extractable information from single-cell RNA-seq data. Genome Res. 2016;26:1397–410.}). Briefly, ESAT evaluates reads mapped immediately downstream of annotated genes for potential quantification with the adjacent gene, an approach particularly relevant to 3’ scRNA-Seq data with reference transcriptomes with incomplete 3’UTR annotations. To eliminate ambiguous read assignments due to “overlapping genes” (i.e. exons from two different genes on + and – strands sharing the same genomic coordinates), the immunoglobulin-supplemented reference transcriptome (Ensembl v95) was additionally modified to remove overlapping exon intervals on opposite strands. Reformatted CellRanger BAM files were processed through ESAT in two rounds. First, ESAT was run (-wExt 2500) with the modified transcriptome reference and set to ignore any duplicated genes. Next, to recover quantification of genes duplicated in the Ensembl v95 reference (n = 185 duplicated genes), ESAT was run (-wExt 2500) a second time with a filtered reference containing only duplicated genes; resulting read counts were divided across gene duplications and appended to the initial gene x cell count matrix.

## Doublet removal

Putative “doublet” cell barcodes were identified and removed from downstream analyses with the DoubletDetection tool {Adam Gayoso, Jonathan Shor. GitHub: DoubletDetection. Zenodo; 2019. doi:10.5281/zenodo.2678042}.

# Results

# Set up R environment
```{r echo = FALSE, message=FALSE}
### Load packages necessary for script
library(renv)
library(Matrix)
library(AnnotationDbi)
library(tibble)
library(gtools)
library(cowplot)
library(gdata)
library(clustree)
library(future)
library(rrtools)
library(rlang)
library(uwot)
library(Seurat)
library(sctransform)
library(ggnetwork)
library(RColorBrewer)
library(ggrepel)
library(readxl)
library(ggpubr)
library(lemon)
library(scales)
library(edgeR)
library(dplyr)
library(patchwork)
library(ape)
library(mgsub)
library(jntools)
library(BiocManager)
library(viridis)
library(ggtree)
library(ggforce)
library(legocolors)
library(openxlsx)
library(cluster)
library(factoextra)
library(GEOquery)
library(ComplexHeatmap)
library(circlize)
library(here)
library(reshape2)
library(tidyr)
library(modelr)

### Load custom functions used in this analysis
source(here("R/custom_functions.R"))
### Point to project directory
project_dir <- here("equinepbmc/")
### Set paths for figures and data outputs
figuresPath <- paste0(project_dir, "/analysis/figures/")
derivedDataPath <- paste0(project_dir, "/analysis/data/derived_data/")
### Read on color-annotation file
colorSchema_ePBMC <- as.data.frame(read_excel(path = here("analysis/data/derived_data/colorschema_annotations.xlsx")))
```

# Part 1: Loading and pre-processing gene-cell matrices
First, we read in the ESAT gene-cell matrices processed by the End Sequence Analysis Toolkit (ESAT) for both standard gene expression quantification and rescue of 3' UTR expression for relevant genes. 

```{r Reading in the ESAT processed gene-cell matrices, include=FALSE}
## Pull counts matrices directly from GEO
#tmpdir <- tempdir()
#url <- "https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE148416&format=file"
#file <- basename(url)
#download.file(url, file)
#untar(file, compressed = "gzip", exdir = tmpdir)
## Extract and unzip gene-cell matrices only
tmpdir <- "../data/raw_data/GSE148416_RAW/"
gz.files <- lapply(list.files(path = tmpdir, full.names = T, pattern = "GSM"), gzfile)
counts <- lapply(gz.files, read.table, sep = "\t")
names(counts) <- strsplit(list.files(tmpdir), split = "_") %>% sapply("[[", 2)
counts <- lapply(counts, function(x) {
  colnames(x) <- gsub(x = colnames(x), pattern = ".*\\.", replacement = "")
  return(x)
})
```

Doublets were identified by applying JonathonShor's DoubletDectection python tool (doi: http://doi.org/10.5281/zenodo.2678041). Output of the tool will be used as meta.data for the individual subject Seurat objects.

```{r Apply DoubletFileConverter to doublet files}
doublet_out_dir <- here("analysis/data/raw_data/DoubletDetector_output")
doublet_data <- lapply(list.files(doublet_out_dir, full.names = T), read.table, row.names = 1)
names(doublet_data) <- strsplit(list.files(doublet_out_dir), split = "_") %>% sapply("[[", 1)
doublet_data <- lapply(doublet_data, function(x) {
  rownames(x) <- gsub(x = rownames(x), pattern = ".*:", replacement = "")
  colnames(x) <- "doublet"
  return(x)
})
```

```{r Create Seurat object for each individual subject}
create.seurat.call <- function(x, y) {
  CreateSeuratObject(
    counts = x,
    names.delim = "\\.",
    names.field = 1,
    min.cells = 3,
    min.features = 200,
    meta.data = y
  )
}

seurat.obj <- mapply(create.seurat.call, counts, doublet_data)
```

# Part 2: Quality control and exploration of Seurat object raw data

```{r Create mitochondrial gene character vector to quantify mitochondrial RNA in single cells}
toMatch <- c("ND1", "ND2", "COX1", "COX2", "ATP8", "ATP6", "COX3", "ND3", "ND4", "ND5", "ND6", "CYTB", "ENSECAG00000027676")
```

```{r Qauntify mitochondrial RNA contributions in the single cells in all 7 subjects}
seurat.obj <- lapply(seurat.obj, function(object) {
  object[["percent.mito"]] <- PercentageFeatureSet(object, features = toMatch)/100
  return(object)
})
```

Explore the distribution of quality metrics of the single cell data, per subject. The 3(maybe 4) QC metrics evaluated here are the UMIs/cell (nCount_RNA/cell), genes/cell (nFeature_RNA/cell), percent of transcriptome expressed from mitochondrial genome and the doublet classification of the cell. 

```{r Violin plots of QC metrics}
lapply(seurat.obj, VlnPlot,
  features = c("nCount_RNA", "nFeature_RNA", "percent.mito", "doublet"),
  ncol = 4,
  pt.size = 0.1
)
```

From visual inspection of the violin plots, we set our thresholds to filter the data as following:
* 750 < nCount_RNA < 20000
* 200 < nFeature
* percent.mito < 5%
* doublets < 0.5 (exclude all doublets identified by Doublet detector)

```{r Perform filtering of Seurat objects against user-defined thresholds}
seurat.obj <- lapply(seurat.obj,
  subset,
  subset =
    nCount_RNA < 20000 & nCount_RNA > 750 &
      nFeature_RNA > 200 &
      doublet < 0.5 &
      percent.mito < 0.05
)
```

# Part 3: Normalization (SCTransform), variable gene identification and integration

```{r Independent normalizaiton (SCTransform) for each subject}
## Previous analyses showed clustering/gene expression patterns highly influenced by mitochondrial gene expression, thus we regress it at this step.
seurat.obj <- lapply(seurat.obj, 
                     SCTransform, 
                     vars.to.regress = "percent.mito", 
                     verbose = TRUE)
```

Before we integrate, previous analyses have shown that subsets of the B cell compartment clustered based on there immunoglobulin isotype expression. While biologically relevant, this separation during clustering is troublesome to identify the cell types present in the B cell compartment (i.e. a memory cell expressing IGHG1 versus a memory cell expressing IGHG3). To better identify cell types within the B cells, we exclude the immunoglobulin genes from the integration. 

```{r Exclude immunoglobulin isotypes from the highly variable genes}
ePBMC.integrated.features <- SelectIntegrationFeatures(object.list = seurat.obj, 
                                                       nfeatures = 5500)

immunoglobulin.genes <- c(
  grep(pattern = "^IGH", x = rownames(seurat.obj$s1), value = T)[-1],
    "ENSECAG00000031522", "ENSECAG00000001923",
    "ENSECAG00000039599", "ENSECAG00000038455",
    "ENSECAG00000031094", "ENSECAG00000015109",
    "ENSECAG00000033354"
)

SelectedFeatures <- ePBMC.integrated.features[!ePBMC.integrated.features %in% immunoglobulin.genes]
```

```{r Perform integration of scRNA-seq data from 7 subjects and create a reference dataset}
ePBMC.integrated <- PrepSCTIntegration(
  object.list = seurat.obj, 
  anchor.features = SelectedFeatures,
  verbose = TRUE
)

ePBMC.integrated.anchors <- FindIntegrationAnchors(
  object.list = ePBMC.integrated, 
  normalization.method = "SCT",
  anchor.features = SelectedFeatures, 
  verbose = TRUE
)

ePBMC.integrated.obj <- IntegrateData(
  anchorset = ePBMC.integrated.anchors, 
  normalization.method = "SCT",
  verbose = TRUE
)
```

# Part 4: Dimensional reduction via Principal Component Analysis (PCA)

```{r Dimensional Reduction via Principal component analysis}
ePBMC.integrated.obj <- RunPCA(
  object = ePBMC.integrated.obj,
  npcs = 100,
  verbose = TRUE)
```

```{r Exploratory analysis of principal components and identification of an appropriate number of dimensions}
## Elbow(scree) plots
# Visualize 50 PCs
ElbowPlot(ePBMC.integrated.obj, ndims = 50)

## Percent variance explained point plots
eigValues <- ePBMC.integrated.obj[["pca"]]@stdev^2
total_variance <- ePBMC.integrated.obj[["pca"]]@misc$total.variance
var_explained_per_pc <- (eigValues / total_variance) %>% cumsum()
qplot(
  x = seq_along(var_explained_per_pc), y = var_explained_per_pc,
  asp = 1,
  ylim = c(0, 1)
)

## Heatmaps to explore the principal components
## Set number of dims to visualize
ndims <- 100
## Set number of dimensions to visualize per plot
ndims.plot <- 6
for (i in 1:as.integer(ndims / ndims.plot)) {
  dims <- modelr::seq_range(x = 1:ndims, by = 5)[i:(i + 1)]
  DimHeatmap(object = ePBMC.integrated.obj, dims = dims[1]:dims[2], cells = 100, fast = T, balanced = T)
}
```

After identifying a reasonable number of dimensions, we conduct unsupervised clustering to characterize the heterogeneity of the data and identify the underlying cell types. Based on the previous steps, and in a semi-supervised manner, we chose 25 dimensions to perform downstream analyses.

# Part 5: Unsupervised clustering and supervised scRNA-seq cell quality filtering

```{r Conduct unsupervised clustering on chosen dimensions and 2-D UMAP embedding}
DefaultAssay(ePBMC.integrated.obj) <- "integrated"
# Set finalized number of dimensions
final.dims <- 25
# Perform clustering: Neighbor finding and resolution parameters
ePBMC.integrated.obj <- FindNeighbors(object = ePBMC.integrated.obj, dims = 1:final.dims)

## Use clustree visualization to identify an appropriate resolution parameter that effectively stabilizes clustering
# Test multiple resolutions
ePBMC.integrated.obj <- FindClusters(object = ePBMC.integrated.obj, algorithm = 3, resolution = c(0.01, 0.05, 0.1, seq(0.2, 2, 0.1)))
clustree::clustree(ePBMC.integrated.obj, prefix = "integrated_snn_res.")

# Choose appropriate clustering resolution
res <- "integrated_snn_res.1.2"
ePBMC.integrated.obj <- SetIdent(object = ePBMC.integrated.obj, value = res)

# Run UMAP embedding
ePBMC.integrated.obj <- RunUMAP(ePBMC.integrated.obj,
  dims = 1:25,
  min.dist = 0.6,
  n.neighbors = 75
)

# Build hierarchical clustering based on clustering results
DefaultAssay(ePBMC.integrated.obj) <- "RNA"
ePBMC.integrated.obj <- NormalizeData(ePBMC.integrated.obj)
ePBMC.integrated.obj <- BuildClusterTree(ePBMC.integrated.obj, assay = "RNA", dims = 1:25)
```

Next, we perform additional filtering of doublets based on our knowledge of established immune cell markers. In theory, CD3G+ T cells should not express B cell markers such as MS4A1 or CD19, or immunoglobulins.

```{r Additional step: Identifying cycling cells in the CD3+ lymphocyte compartment}
ePBMC.integrated.obj <- CellCycleScoring(
  object = ePBMC.integrated.obj,
  s.features = cc.genes.updated.2019$s.genes,
  g2m.features = cc.genes.updated.2019$g2m.genes, set.ident =
    FALSE
)
reg.plot <- DimPlot(ePBMC.integrated.obj, group.by = "Phase")
# Manually split this cluster up into two clusters: cluster 21-G2M; cluster 21-S
ePBMC.integrated.obj <- StashIdent(object = ePBMC.integrated.obj, "clusters")
``` 

# Part 6: Differential gene expression testing via edgeR

After clustering, we moved to conduct differential gene expression testing using edgeR. 
For our single cell purposes, one of the primary modifications we make is the inclusion of a gene detection rate parameter, to account for the 'dropout' phenomenon common to single cell RNA seq data {Soneson C, Robinson MD. Bias, robustness and scalability in single-cell differential expression analysis. Nature Methods. 2018;15:255–61.}. Additional parameters, we include while building our model are factors for each horse and each cluster, identified by the high-resolution unsupervised clustering.

## Part 6.1: Setting up and generating edgeR model and fit

```{r Setting up edgeR objects for differential gene expression testing}
## Order the Seurat objects identities from low to high numerically
ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "clusters")
ePBMC.integrated.obj@meta.data$order <- factor(x = ePBMC.integrated.obj$clusters, levels = seq(0, 31))
ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "order")
ePBMC.integrated.obj$order <- droplevels(ePBMC.integrated.obj$order)

## Add Subject meta data
ePBMC.integrated.obj$Subject <- paste0("Subject_", right(rownames(ePBMC.integrated.obj@meta.data), 1))
ePBMC.integrated.obj$Subject <- as.factor(ePBMC.integrated.obj$Subject)

## Add annotation metadata to integrated ePBMC object
ePBMC.integrated.obj$cell_barcode <- rownames(ePBMC.integrated.obj@meta.data)
colorSchema_ePBMC$order <- as.factor(colorSchema_ePBMC$Cluster)
updated_metadata <- right_join(colorSchema_ePBMC, ePBMC.integrated.obj@meta.data, by = "order")
rownames(updated_metadata) <- updated_metadata$cell_barcode
ePBMC.integrated.obj <- AddMetaData(ePBMC.integrated.obj, metadata = updated_metadata)

### Generate edgeR fit, counts DGElist and design matrix
edgeRobj <- edgeR_create_fit(
  object = ePBMC.integrated.obj,
  gene.detection.thres = 0.10,
  celltype.ident = "order"
)
```

## Part 6.2: Generating contrasts for major cell groups and subsets within major groups

```{r Generate constrasts major groups for equine PBMC analysis}
# set major group/compartment vectors
B.clusters <- c(9, 15, 0, 22, 25, 27, 30)
basophils.clusters <- c(23)
cd3prf1neg.clusters <- c(2, 7, 8, 31, 16, 1, 13, 10, 21, 3, 6)
cd3prf1pos.clusters <- c(4, 5, 14, 17, 20)
dc.clusters <- c(19, 24, 26)
mono.clusters <- c(18, 11, 12, 28)
myeloid.clusters <- c(18, 11, 12, 28, 19, 24, 26, 29)

assignment.list <- list(
  B.clusters,
  basophils.clusters,
  cd3prf1neg.clusters,
  cd3prf1pos.clusters,
  dc.clusters,
  mono.clusters,
  myeloid.clusters
)

names(assignment.list) <- grep(ls(), pattern = "\\.clusters", value = T)

major.group.contrasts <-
  lapply(
    seq_along(assignment.list),
    function(x) {
      contrastConstructor(
        clusterIDs = assignment.list[[x]],
        design = edgeRobj$design,
        name = names(assignment.list)[[x]],
        makeContrast = TRUE
      )
    }
  )

major.group.contrasts <- do.call(cbind, major.group.contrasts)
colnames(major.group.contrasts) <- names(assignment.list)
```

```{r Generate constrasts for subsets within major groups for equine PBMC analysis}
assignment.list$basophils.clusters <- NULL

lapply(
  seq_along(assignment.list),
  function(x) {
    for (i in 1:length(assignment.list[[x]])) {
      contrastConstructor(
        clusterIDs = assignment.list[[x]][[i]],
        clusterIDs.2 = setdiff(assignment.list[[x]], assignment.list[[x]][[i]]),
        design = edgeRobj$design,
        makeContrast = T,
        name = paste(names(assignment.list)[[x]], "subset", assignment.list[[x]][[i]], sep = "_")
      )
    }
  }
)

subset.cluster.contrasts <- do.call(cbind, lapply(grep(ls(), pattern = "_subset_", value = T), get))
subset.cluster.contrasts <- as.data.frame(subset.cluster.contrasts)
colnames(subset.cluster.contrasts) <- grep(ls(), pattern = "_subset_", value = T)
```

## Part 6.3: Conducted differential gene expression testing between major cell groups and between groups

```{r Conduct differential gene expression testing for major cell groups and subsets}
major_dge_list <- list()
for (i in 1:length(colnames(major.group.contrasts))) {
  major_dge_list[[i]] <- glmQLFTest(edgeRobj$fit, contrast = major.group.contrasts[, i]) %>%
    topTags(n = NULL)
}

subset_dge_list <- list()
for (i in 1:length(colnames(subset.cluster.contrasts))) {
  subset_dge_list[[i]] <- glmQLFTest(edgeRobj$fit, contrast = subset.cluster.contrasts[, i]) %>%
    topTags(n = NULL)
}
```

## Part 6.4: Append percent.expression feature data and putative surface protein classification to differential gene expression tables

```{r Append percent.expression feature data and putative surface protein classification to differential gene expression tables}
major_dge_list <- add.percent.expression(
  dge_list = major_dge_list, object = ePBMC.integrated.obj,
  ident = "MajorGroup"
)

major.groups <- unique(ePBMC.integrated.obj$MajorGroup)

b.dge.list <- add.percent.expression(
  dge_list = mono.dge.list,
  object = ePBMC.integrated.obj,
  ident = "order",
  group.ident = "MajorGroup",
  subset = "B"
)

monodc.dge.list <- add.percent.expression(
  dge_list = mono.dge.list,
  object = ePBMC.integrated.obj,
  ident = "order",
  group.ident = "MajorGroup",
  subset = "Monocyte&DC"
)

basophil.dge.list <- add.percent.expression(
  dge_list = mono.dge.list,
  object = ePBMC.integrated.obj,
  ident = "order",
  group.ident = "MajorGroup",
  subset = "basophil"
)
```

# Part 7: Figure plotting

The sections below details the code/scripts used to generate all of the scRNA-seq related figures for the manuscript.

## Part 7.1: Major group analysis - Figure 1

```{r Set up object to plot appropriate identities and gene expression values}
ePBMC.integrated.obj$Subject <- factor(ePBMC.integrated.obj$orig.ident, levels = c("Subject 1", "Subject 2", "Subject 3", "Subject 4", "Subject 5", "Subject 6", "Subject 7"))

# Set assay to RNA to visualize gene expression and log normalize count values
DefaultAssay(ePBMC.integrated.obj) <- "RNA"
ePBMC.integrated.obj <- NormalizeData(ePBMC.integrated.obj)
```

### Figure 1A: Global UMAP of all immune cell clusters/groups

```{r Global UMAP of all clusters/groups}
cluster.umap.plot(
  object = ePBMC.integrated.obj, byrow = F,
  group.ident = "order", inset = F,
  colors = colorSchema_ePBMC$colors
)
```

### Figure 1B: Feature plots of relevant immunophenotyping markers

```{r Feature plots of relevant immunophenotyping markers}
# Set vector for markers to visualize
markers <- c(
  "CD3G", "ENSECAG00000000419",
  "PRF1", "CTSW",
  "MPEG1", "DRA",
  "CST3", "CD14",
  "MS4A1", "CD79A",
  "LTC4S", "GATA2"
)
# Generate plots using preset parameters
plots <- FeaturePlot.c(object = ePBMC.integrated.obj, features = markers)
# Customize FeaturePlot for figure generation
plots.m <- lapply(plots, function(x) {
  x + NoAxes() + theme(
    plot.title = element_text(size = 8, face = "italic"),
    legend.position = "none",
    legend.key.width = unit(x = 0.25, units = "cm"),
    legend.key.height = unit(x = 0.1, units = "cm"),
    legend.title = element_text(size = 4, face = "italic"),
    legend.text = element_text(size = 5),
    legend.direction = "horizontal",
    plot.margin = margin(0, 0, 0, 0),
  ) +
    scale_colour_continuous(breaks = pretty_breaks(n = 3), limits = c(NA, NA), low = "grey95", high = "darkgreen") +
    labs(color = "Expression \n")
})
cowplot::plot_grid(plotlist = plots.m, scale = 0.9)
```

### Figure 1C Heatmap: Heatmap of DEGs between major cell groups

```{r Heatmap of DEGs between major cell groups}
major_tables <- major.glmQLFTest
major_tables <- major_tables[c("CD3PRF1neg", "CD3PRF1pos", "B", "Monocyte&DC", "Basophil")]
major_tables <-
  lapply(major_tables, tibble::remove_rownames) %>% lapply(tibble::column_to_rownames, "genes")
major.genes <- lapply(
  major_tables,
  function(df) {
    df[order(df$logFC, decreasing = T), ]
  }
) %>%
  lapply(rownames) %>%
  unlist2() %>%
  unique()

major.flag <- lapply(major_tables, function(df) {
  df[order(df$logFC, decreasing = T), ]
}) %>%
  lapply(function(x) {
    print(rownames(x))
  }) %>%
  lapply(head, 5) %>%
  unlist2()

ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "final_lineage")
levels(ePBMC.integrated.obj) <- c("CD3PRF1neg", "CD3PRF1pos", "B", "Monocyte&DC", "Basophils", "NA")

major.hmp <- prettyheatmap(
  object = subset(ePBMC.integrated.obj, idents = "NA", invert = T),
  gene.list = major.genes,
  text.size = 8,
  flagged_genes = major.flag,
  downsample = 210,
  colors = c("#C8E6C9", "#A1887F", "#8783BE", "#EF9A9A", "#9E9E9E", "gray"),
  ident = "final_lineage",
  order = levels(ePBMC.integrated.obj)
)
major.hmp
```

### Figure 1D. Stacked bars: Cell frequencies of major cell groups across subjects

```{r Cell frequencies of major cell groups across subjects}
ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "order")

new.groupings <- colorSchema_ePBMC$major_groups %>%
  gsub(pattern = "Myeloid", replacement = "Monocytes&DCs") %>%
  gsub(pattern = "NK", replacement = "Natural killer")
names(x = new.groupings) <- levels(x = ePBMC.integrated.obj)
ePBMC.integrated.obj <- RenameIdents(object = ePBMC.integrated.obj, new.groupings)
ePBMC.integrated.obj <- StashIdent(ePBMC.integrated.obj, save.name = "horse.major.celltype")

horse_cluster_freq.table <- table(ePBMC.integrated.obj$Subject, ePBMC.integrated.obj$horse.major.celltype) %>% melt()
colnames(horse_cluster_freq.table) <- c("Subject", "Celltype", "Fraction_of_all_cells")
horse_cluster_freq.table$celltype <- as.factor(horse_cluster_freq.table$Celltype)
horse_cluster_freq.table$celltype <- droplevels(horse_cluster_freq.table$Celltype)
ggplot(horse_cluster_freq.table, aes(
  x = Subject,
  y = Fraction_of_all_cells,
  fill = factor(Celltype, levels = c(
    "Noncyto", "Cyto", "B", "Monocytes&DCs", "Basophils"
  ) %>%
    rev())
)) +
  geom_bar(stat = "identity", position = "fill", width = 0.9666) +
  scale_fill_manual(
    label = rev(c("CD3+PRF1-", "CD3+PRF1+", "B", "Monocytes&DCs", "Basophils")),
    values = c("#9E9E9E", "#EF9A9A", "#8783BE", "#A1887F", "#C8E6C9")
  ) +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0)) +
  coord_flip() +
  ylab(label = "Fraction of all cells") +
  scale_x_discrete(limits = rev(levels(horse_cluster_freq.table$Subject))) +
  labs(fill = "celltype")
```

## Part 7.2: Monocyte&DC analysis - Figure 2

### Setting up objects for myeloid cell analysis

```{r Setting up objects for myeloid cell analysis}
# For myeloid cells (Monos + DCs) subset involved clusters.
{
  Mcells.order <- c(18, 11, 12, 28, 19, 24, 26, 29)
  ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "order")
  Mcells <- subset(ePBMC.integrated.obj, idents = Mcells.order)
}

## Set color vector and create myeloid cell color vector for subsequent figures
{
  colors <- colorSchema_ePBMC$colors
  M.cols <- colors[c(as.numeric(Mcells.order) + 1)]
  names(M.cols) <- as.numeric(Mcells.order)
}
```

### Figure 2A. UMAP of myloid cell clusters w/ inset

```{r UMAP of myloid cell clusters w/ inset}
## UMAP with inset and circles
inset.plot.raw <- DimPlot(
  object = Mcells,
  pt.size = 0.1, cols = unique(colorSchema_ePBMC$MyeloidnDCs)[-1], label = F, na.value = "grey95"
) + NoLegend() + coord_fixed() + NoAxes()

monos_dcs_inset_labeled <- custom.LabelClusters(
  plot = inset.plot.raw, id = "ident",
  clusters = as.character(Mcells.order),
  circle.size = 8,
  text.size = 5,
  fill = M.cols,
  repel = T
)

p1 <- monos_dcs_inset_labeled + theme(panel.border = element_rect(colour = "black"), axis.line = element_blank())
p2 <- DimPlot(
  object = ePBMC.integrated.obj,
  pt.size = 0.1, cols = colorSchema_ePBMC$MyeloidnDCs, label = F, na.value = "grey95"
) + NoLegend() + coord_fixed() + NoAxes() +
  theme(panel.border = element_rect(colour = "black"), axis.line = element_blank())
p1 + annotation_custom(ggplotGrob(p2),
  xmin = 4, xmax = 7.5,
  ymin = 4, ymax = 8
)
```

### Figure 2B. Stacked bars of cell types frequencies in monocyte/DC compartment across horses

```{r Stacked bars}
## Remove contaminating nuetrophils (low UMI)
Mcells.sub <- subset(Mcells, idents = 29, invert = T)
Mcells.sub$order <- droplevels(Mcells.sub$order)
horse_mono.dc.cluster_freq.table <- table(Mcells.sub$Subject, Mcells.sub$order) %>% melt()
colnames(horse_mono.dc.cluster_freq.table) <- c("Subject", "Celltype", "Fraction_of_all_cells")
horse_mono.dc.cluster_freq.table$Celltype <- as.factor(horse_mono.dc.cluster_freq.table$Celltype)

ggplot(horse_mono.dc.cluster_freq.table, aes(
  x = Subject,
  y = Fraction_of_all_cells,
  fill = factor(Celltype, levels = Mcells.order)
)) +
  labs(fill = "Celltype") +
  geom_bar(stat = "identity", position = "fill", width = 0.9666) +
  scale_fill_manual(values = M.cols) +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0)) +
  coord_flip() +
  scale_x_discrete(limits = rev(levels(horse_mono.dc.cluster_freq.table$Subject)))
```

### Figure 2C. Hierarchical clustering of monocyte/DC compartment by RNA

```{r Hierarchical clustering of monocyte/DC compartment by RNA}
## Hierarchical clustering by RNA
Mcells.sub <- subset(ePBMC.integrated.obj, idents = Mcells.order[-length(Mcells.order)])
Mcells.sub$order <- droplevels(Mcells.sub$order)
Mcells.sub <- BuildClusterTree(object = Mcells.sub, dims = 1:25, assay = "RNA")
tree <- plottree(Mcells.sub)
levels(Mcells.sub) <- Mcells.order[-length(Mcells.order)]
```

### Figure 2D. Heatmap of genes differentially expressed by each monocyte/dc cluster

```{r Heatmap of genes differentially expressed by each monocyte/dc cluster}
dge_tbl <- Myeloid.glmQLFTest
names(dge_tbl) <- gsub(x = names(dge_tbl), "[^0-9.-]", "")

## order tables in the same order as object identities/names match
dge_tbl <- dge_tbl[levels(Mcells.sub)]
dge_tbl <-
  lapply(dge_tbl, tibble::remove_rownames) %>% lapply(tibble::column_to_rownames, "genes")
dge.genes <- lapply(
  dge_tbl,
  function(df) {
    df[order(df$logFC, decreasing = T), ]
  }
) %>%
  lapply(rownames) %>%
  unlist2() %>%
  unique()

flag.genes <- lapply(dge_tbl, function(df) {
  df[order(df$logFC, decreasing = T), ]
}) %>%
  lapply(function(x) {
    print(rownames(x))
  }) %>%
  lapply(head, 5) %>%
  unlist2() %>%
  unique()

Mcells.sub@meta.data$name <- rownames(Mcells.sub@meta.data)
test <- Mcells.sub@meta.data %>%
  group_by(Subject, order) %>%
  sample_n(size = )
Major.cellnames <- test$name

monodc.hmp <- prettyheatmap(
  object = Mcells.sub,
  gene.list = dge.genes,
  text.size = 8,
  flagged_genes = flag.genes,
  downsample = 25,
  colors = M.cols,
  ident = "order",
  order = levels(Mcells.sub)
)
monodc.hmp
```

### Figure 2E. Dotplot of select DEGs in the monocyte clusters

```{r Dotplot of select DEGs in monocytes}
Monos <- subset(Mcells.sub, idents = Mcells.order[1:4])
Mono.order <- as.character(Mcells.order[1:4])
Mono.cols <- colors[c(as.numeric(Mono.order) + 1)]
names(Mono.cols) <- Mono.order
mono.genes <- c(
  "CD14", "LYZ", "S100A12", "MMP9", "SELL", "CD44", "THBS1", "CD163", "EMP1",
  "REXO2", "CX3CR1", "ENSECAG00000006663", "CD8A", "ICAM2", "HES4", "NR4A1", "DRA", "DRB"
)
seurat.dotplot <- DotPlot(
  object = Monos,
  features = rev(mono.genes)
) +
  RotatedAxis()

prettyDots(dotplot = seurat.dotplot, colors = Mono.cols, col.min = -1.5, col.max = 1.5)
```

### Figure 2F. Dotplot of select DEGs in the DC clusters

```{r Dotplot of select DEGs in DCs}
dc <- subset(Mcells.sub, idents = Mcells.order[5:7])
dc.order <- Mcells.order[5:7]
dc.cols <- colors[c(as.numeric(dc.order) + 1)]
names(dc.cols) <- dc.order
levels(dc) <- dc.order
dc.genes <- c(
  "FLT3", "CD4", "ITGAM", "CD14", "SPI1", "CLEC9A", "CADM1", "CD8A", "IRF8",
  "FCER1A", "CD1E2", "IRF7", "TCF4", "IFNAR1", "DRB", "DRA"
)
seurat.dotplot <- DotPlot(
  object = dc,
  features = rev(dc.genes)
) +
  RotatedAxis()

prettyDots(dotplot = seurat.dotplot, colors = dc.cols, col.min = -1.5, col.max = 1.5)
```

### Figure 2G. Cross-species dendrogram between human and equine cell type clusters identified by scRNAseq

This code requires the processed human PBMC reference dataset. This method was inspired by Zilionis R, Engblom C, Pfirschke C, Savova V, Zemmour D, Saatcioglu HD, et al. Single-Cell Transcriptomics of Human and Mouse Lung Cancers Reveals Conserved Myeloid Populations across Individuals and Species. Immunity. 2019. doi:10.1016/j.immuni.2019.03.009.

```{r  Cross-species dendrogram between human and equine cell type clusters identified by scRNAseq}
# Set identity class to high-resolution clustering results
# Human
human_pbmc <- SetIdent(human_pbmc, value = "integrated_snn_res.1.2")
# Horse
ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "order")

dendo <- cross_species_dendrogram(species.1.obj = ePBMC.integrated.obj, 
                                  species.2.obj = human_pbmc,
                                  species1.ident =  Mcells.order[-length(Mcells.order)], 
                                  species2.ident = c(14, 21, 15, 0, 1, 8, 22, 26, 19),
                                  species1.res = "order", 
                                  species2.res = "human.celltype",
                                  species1.name = "horse", 
                                  species2.name = "human")

dtree <- ggtree(tr = dendo, layout = "rectangular") +
  geom_tiplab(
    align = F,
    as_ylab = T
  ) +
  theme(axis.text = element_text(size = 22))
dtree
```

## Part 7.3: B cell analysis - Figure 3
### Setting up objects for B lymphocyte analysis

```{r Setting up objects for B lymphocyte analysis}
# For B lymphocyte subset involved clusters.
{
  Bcells.order <- c(9, 15, 0, 22, 25, 27, 30)
  ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "order")
  Bcells <- subset(ePBMC.integrated.obj, idents = Bcells.order)
}

## Set color vector and create myeloid cell color vector for subsequent figures
{
  colors <- colorSchema_ePBMC$colors
  B.cols <- colors[c(as.numeric(Bcells.order) + 1)]
  names(B.cols) <- as.numeric(Bcells.order)
}
```

### Figure 3A. UMAP of B lymphocyte clusters w/ inset

```{r UMAP of B lymphocyte clusters w/ inset}
## UMAP with inset and circles
B.inset.plot.raw <- DimPlot(
  object = ePBMC.integrated.obj, na.value = "grey95",
  pt.size = 0.1, cols = colorSchema_ePBMC$`B colors`, label = F
) + NoLegend() + coord_fixed() + NoAxes()
B_inset_labeled <- custom.LabelClusters(
  plot = B.inset.plot.raw, id = "ident",
  clusters = as.character(Bcells.order),
  circle.size = 8,
  text.size = 5,
  fill = B.cols,
  repel = T
)
p1 <- B_inset_labeled + theme(panel.border = element_rect(colour = "black"), axis.line = element_blank())
p2 <- DimPlot(
  object = ePBMC.integrated.obj,
  pt.size = 0.1, cols = colorSchema_ePBMC$`B colors`, label = F, na.value = "grey95"
) + NoLegend() + coord_fixed() + NoAxes() +
  theme(panel.border = element_rect(colour = "black"), axis.line = element_blank())
p1 + annotation_custom(ggplotGrob(p2),
  xmin = -10.5, xmax = -4,
  ymin = 7, ymax = 15.5
)
```

### Figure S4A.Violin plots illustrating low UMI distribution of cluster 25

```{r Violin plots illustrating low UMI distribution of cluster 25}

b.ncountRNA.vln <- VlnPlot(Bcells, features = c("nCount_RNA"), cols = B.cols, pt.size = 0, combine = F)
b.ncountRNA.vln <- lapply(
  b.ncountRNA.vln,
  function(x) {
    x$labels$y <- x$labels$title
    x + theme(plot.title = element_blank(), axis.title.x = element_blank(), axis.title.y = element_text(face = "bold")) +
      scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) + NoLegend()
  }
)
CombinePlots(plots = b.ncountRNA.vln)

## Remove cluster 25 from downstream B cell analysis
Bcells <- subset(ePBMC.integrated.obj, idents = c(9, 15, 0, 22, 27, 30))
## Set/order levels to B cell differentiation (our idea of*)
levels(Bcells) <- c(9, 15, 0, 22, 30, 27)
```

### Figure 3B. Stacked bars of cell types frequencies in B lymphocyte compartment across horses

```{r Stacked bars of cell types frequencies in B lymphocyte compartment across horses}
Bcells <- StashIdent(Bcells, save.name = "order")
horse_B_freq.table <- table(Bcells$Subject, Bcells$order) %>% melt()
colnames(horse_B_freq.table) <- c("Subject", "Celltype", "Fraction_of_all_cells")
horse_B_freq.table$Celltype <- as.factor(horse_B_freq.table$Celltype)

B.cols <- c("#D1C4E9", "#6363A8", "#8783BE", "#3E4393", "purple", "#1A237E")
library(ggplot2)
ggplot(horse_B_freq.table, aes(
  x = Subject,
  y = Fraction_of_all_cells,
  fill = factor(Celltype, levels = c("9", "15", "0", "22", "27", "30"))
)) +
  labs(fill = "Celltype") +
  geom_bar(stat = "identity", position = "fill", width = 0.9666) +
  scale_fill_manual(values = B.cols) +
  theme_classic() +
  scale_y_continuous(expand = c(0, 0)) +
  coord_flip() +
  scale_x_discrete(limits = rev(levels(horse_B_freq.table$Subject)))
```

### Figure 3C. Hierarchical clustering of B lymphocyte compartment by RNA

```{r Hierarchical clustering of B lymphocyte compartment by RNA}
## Hierarchical clustering by RNA
Bcells <- BuildClusterTree(Bcells, dims = 1:25, assay = "RNA")
plottree(Bcells)
```

### Figure 3D. Heatmap of genes differentially expressed by each B lymphocyte cluster

```{r Heatmap of genes differentially expressed by each B lymphocyte cluster}
dge_tbl <- B.glmQLFTest
names(dge_tbl) <- gsub(x = names(dge_tbl), "[^0-9.-]", "")

## order tables in the same order as object identities/names match
dge_tbl <- dge_tbl[levels(Bcells)]
dge_tbl <-
  lapply(dge_tbl, tibble::remove_rownames) %>% lapply(tibble::column_to_rownames, "genes")
dge.genes <- lapply(
  dge_tbl,
  function(df) {
    df[order(df$logFC, decreasing = T), ]
  }
) %>%
  lapply(rownames) %>%
  unlist2() %>%
  unique()

flag.genes <- c(
  "CXCR4", "IGHD", "SELL",
  "ZBTB20", "ID3", "SELPLG", "LGALS1",
  "TBX21", "POU2F2", "FGR", "ITM2C", "ITGAM",
  "BATF",
  "TOP2A", "PCNA", "UBE2C",
  "XBP1", "PRDM1", "IRF4", "SEC61B"
)

B.hmp <- prettyheatmap(
  object = Bcells,
  gene.list = dge.genes,
  text.size = 8,
  flagged_genes = flag.genes,
  downsample = 25,
  colors = B.cols,
  ident = "order",
  order = levels(Bcells)
)
B.hmp
```

### Figure 3E. Dotplot of select transcription factor DEGs in B lymphocyte clusters

```{r Dotplot of select transcription factor DEGs in B lymphocyte clusters}
b.transcriptionfactor.genes <- c(
  "ID3", "HIF1A",
  "MEF2C", "ZBTB20",
  "TBX21", "POU2F2", "ENSECAG00000029287",
  "BATF", "IRF5",
  "EZH2", "E2F2",
  "XBP1", "PRDM1", "IRF4"
)
seurat.dotplot <- DotPlot(
  object = Bcells,
  features = rev(b.transcriptionfactor.genes)
) +
  RotatedAxis()

prettyDots(dotplot = seurat.dotplot, colors = B.cols, col.min = -2.5, col.max = 2.5)
```

### Figure 3F. Violin plots of immunoglobulin genes in B lymphoycyte clusters

```{r Violin plots of immunoglobulin genes in B lymphoycyte clusters}
immunoglobulin.genes <- c(
  "IGHM",
  "IGHD",
  "IGHG1",
  "IGHG2",
  "IGHG3",
  "IGHG4",
  "IGHG5",
  "IGHG6",
  "IGHE",
  "IGHA"
)
b.ig.vln.plots <- VlnPlot(Bcells,
  features = immunoglobulin.genes,
  pt.size = 0,
  ncol = 1,
  cols = B.cols,
  idents = c(9, 15, 0, 22, 27), combine = F
)
b.ig.vln.plots <- lapply(
  b.ig.vln.plots,
  function(x) {
    x$labels$y <- x$labels$title
    x + theme(plot.title = element_blank(), axis.title.x = element_blank(), axis.title.y = element_text(face = "bold.italic")) +
      scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) + NoLegend()
  }
)
CombinePlots(b.ig.vln.plots, ncol = 1)
```

### Figure S4A.Donut plots illustrating low UMI distribution of cluster 25

```{r}
## Subset the plasma cells from the total object (identity = 27)
ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "order")
plasmas <- subset(ePBMC.integrated.obj, idents = 27)

## identify the main/highest expressed immunoglobulin isotype per cell for all plasma cells
ig.max <- plasmas@assays$RNA@counts[immunoglobulin.genes, ] %>% apply(
  MARGIN = 2,
  FUN = which.max
)
## add highest ig isotype classification to metadata
plasmas$max.ig <- immunoglobulin.genes[ig.max]
## Subset subject-main ig isotype information into new dataframe
max.ig.df <- plasmas@meta.data[, c("Subject", "max.ig")]
max.ig.df.t <- table(max.ig.df$max.ig, max.ig.df$Subject)
max.ig.df.t.m <- melt(max.ig.df.t)
colnames(max.ig.df.t.m) <- c("Ig", "Subject", "Freq")
# compute fractions
library(dplyr)
library(magrittr)
max.ig.df.t.m %<>% group_by(Subject) %>% mutate(
  fraction = Freq / sum(Freq),
  ymax = cumsum(fraction),
  ymin = c(0, ymax[1:length(ymax) - 1]),
  cellnum = sum(Freq)
)

# Add x limits
baseNum <- 8
# numCat <- length(unique(dat$ring))
max.ig.df.t.m$xmax <- as.numeric(max.ig.df.t.m$Subject) + baseNum
max.ig.df.t.m$xmin <- max.ig.df.t.m$xmax - 1

# plot per subject
ggplot(max.ig.df.t.m, aes(
  fill = Ig,
  x = factor(Subject),
  y = Freq,
  ymax = ymax,
  ymin = ymin,
  xmax = 6,
  xmin = 9
)) +
  geom_rect(position = "fill", col = "black") +
  coord_polar(theta = "y") +
  theme_void() +
  facet_wrap(~Subject, ncol = 7) +
  theme(panel.grid = element_blank()) +
  theme(axis.text = element_blank()) +
  theme(
    axis.ticks = element_blank(),
    panel.border = element_blank()
  ) +
  geom_text(x = 0.3, y = 0.2, aes(label = cellnum), size = 8) +
  scale_fill_manual(values = RColorBrewer::brewer.pal(n = 7, name = "Dark2"))
```

### Figure 3G. Cross-species dendrogram between human and equine B cell type clusters identified by scRNAseq

This code requires the processed human PBMC reference dataset. This method was inspired by Zilionis R, Engblom C, Pfirschke C, Savova V, Zemmour D, Saatcioglu HD, et al. Single-Cell Transcriptomics of Human and Mouse Lung Cancers Reveals Conserved Myeloid Populations across Individuals and Species. Immunity. 2019. doi:10.1016/j.immuni.2019.03.009.

```{r Cross-species dendrogram between human and equine B cell type clusters identified by scRNAseq}
# Human
human_pbmc <- SetIdent(human_pbmc, value = "integrated_snn_res.1.2")
# Horse
ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "order")

dendo <- cross_species_dendrogram(species.1.obj = ePBMC.integrated.obj, 
                                  species.2.obj = human_pbmc,
                                  species1.ident =  c(9, 15, 0, 22, 27, 30), 
                                  species2.ident = c(3, 11, 23),
                                  species1.res = "order", 
                                  species2.res = "human.celltype",
                                  species1.name = "horse", 
                                  species2.name = "human")

dtree <- ggtree(tr = dendo, layout = "rectangular") +
  geom_tiplab(
    align = F,
    as_ylab = T
  ) +
  theme(axis.text = element_text(size = 22))
dtree
```

## Part 7.4: T-bet+ B lymphocyte exploration - Figure 4

### Figure 4A. Feature plots of select genes defining the T-bet+ B cell clusters 0 and 22

```{r T-bet+ B cell FeaturePlots}
## T-bet+ B cell FeaturePlots
plots <- FeaturePlot.c(object = Bcells, features = c(
  "TBX21", "AICDA", "DRA", "CD86",
  "ITGAX", "ITGAM", "ENSECAG00000031055", "FCER2",
  "FCRL4", "FGR", "HCK", "LCK"
))
# Customize FeaturePlot for figure generation
plots.m <- lapply(plots, function(x) {
  x + NoAxes() + theme(
    plot.title = element_text(size = 12, face = "bold.italic"),
    legend.key.width = unit(x = 0.25, units = "cm"),
    legend.key.height = unit(x = 0.1, units = "cm"),
    legend.title = element_text(size = 4),
    legend.text = element_text(size = 5),
    plot.margin = margin(0, 0, 0, 0),
    legend.position = "none"
  ) +
    scale_colour_continuous(breaks = pretty_breaks(n = 3), limits = c(NA, NA), low = "grey95", high = "darkgreen") +
    labs(color = "Expression \n")
})
CombinePlots(plots.m, ncol = 4)
```

## Part 7.5: CD3+ PRF1+ lymphocyte analysis - Figure 5
Due to difficulty resolving T/NK cell populations (relative to other cell types) by scRNA-seq, we performed an subclustering strategy (new highly variable genes and PCs identified) to better annotate the CD3+ PRF1+ and CD3+ PRF1- lymphocyte compartments.

### Subclustering analysis of the CD3+PRF1+ lymphocyte compartment

```{r Subclustering analysis of the CD3+PRF1+ lymphocyte compartment}
## Subset CD3+PRF1+ cell compartment/major group
ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "final_lineage")
subset.name <- "CD3PRF1pos"
obj <- subset(ePBMC.integrated.obj, idents = subset.name)

obj.split <- SplitObject(obj, split.by = "Subject")
obj.split <- lapply(obj.split, SCTransform, vars.to.regress = "percent.mito", verbose = TRUE)
obj.features <- SelectIntegrationFeatures(object.list = obj.split, nfeatures = 5500)
immunoglobulin.genes <- c(
  grep(pattern = "^IGH", x = rownames(ePBMC.integrated.obj), value = T)[-1],
  "ENSECAG00000031522", "ENSECAG00000001923",
  "ENSECAG00000039599", "ENSECAG00000038455",
  "ENSECAG00000031094", "ENSECAG00000015109",
  "ENSECAG00000033354", "ENSECAG00000007258"
)
SelectedFeatures <- obj.features[!obj.features %in% immunoglobulin.genes]

obj.split <- PrepSCTIntegration(
  object.list = obj.split, anchor.features = SelectedFeatures,
  verbose = TRUE
)

anchors <- FindIntegrationAnchors(
  object.list = obj.split, normalization.method = "SCT",
  anchor.features = SelectedFeatures, verbose = TRUE
)

prf1pos.int <- IntegrateData(
  anchorset = anchors,
  normalization.method = "SCT",
  verbose = TRUE
)

prf1pos.int <- RunPCA(
  object = prf1pos.int,
  npcs = 100, verbose = TRUE,
  features = SelectedFeatures
)
ElbowPlot(prf1pos.int, ndims = 50)
DefaultAssay(prf1pos.int) <- "integrated"
# Set finalized number of dimensions
final.dims <- 30

# Perform clustering: Neighbor finding and resolution parameters
prf1pos.int <-
  prf1pos.int %>%
  FindNeighbors(dims = 1:final.dims) %>%
  FindClusters(algorithm = 3, resolution = 0.8) %>%
  RunUMAP(dims = 1:final.dims, min.dist = 0.5)

# Choose appropriate clustering resolution
res <- "integrated_snn_res.0.8"
# Choose appropriate clustering resolution
prf1pos.int <- SetIdent(object = prf1pos.int, value = res)
```

### Differential gene expressiontesting for reclustering analysis: CD3+ PRF1+ lymphocyte compartment

```{r Differential gene expressiontesting for reclustering analysis: CD3+ PRF1+ lymphocyte compartment}
GeneDetector(SeuratObj = prf1pos.int, threshold = 0.10, listname = "prf1.pos.marker.names")
## Filter the raw gene-cell counts matrix(stored in the Seurat object) with the gene identified above

tmp.matrix <- prf1pos.int@assays$RNA@counts[prf1.pos.marker.names, ]

## Create the Seurat object again, very important this is done because it will adjust how the nGenes are calculated.
## This is very important for the gdr calculation below

tmp <- CreateSeuratObject(tmp.matrix)
colnames(tmp@meta.data)[3] <- "Recalculated_nGene"
tmp <- AddMetaData(object = tmp, metadata = prf1pos.int@meta.data)

## Calculate the gdr from the nGene column in the Seurat metadat

tmp@meta.data$gdr <- as.numeric(scale(tmp@meta.data$Recalculated_nGene))
tmp@meta.data$orig.ident <- NULL

## Create counts object from the edgeR package
counts <- DGEList(counts = tmp@assays$RNA@counts, genes = rownames(tmp))
## Calculate the library sizes of each single cell to be analyzed
counts$samples$lib.PBMSCize <- colSums(counts$counts)
## Calculate the normalization factors to be applied to make single cell comparable
counts <- edgeR::calcNormFactors(counts)

## Reformat metadata from the SeuratObj to make compatible with edgeR/design matrix

edgeRmetadata <- tmp@meta.data[, c("horse", "integrated_snn_res.0.8", "gdr")]
colnames(edgeRmetadata)[2] <- c("celltype")
design <- model.matrix(~ 0 + gdr + celltype + horse, data = edgeRmetadata)

## Estimate dispersion

counts <- estimateDisp(counts, design, robust = T)

## Perform the edgeR fit

fit <- glmQLFit(counts, design)

## Generate contrasts to run differential gene expression testing between CD3+ PRF1+ lymphocyte clusters
cluster.numbers <- 0:8
for (i in 1:length(cluster.numbers)) {
  contrastConstructor(
    clusterIDs = cluster.numbers[i],
    clusterIDs.2 = setdiff(cluster.numbers, cluster.numbers[i]),
    design = design,
    makeContrast = T,
    name = paste("cd3prf1pos_reclustered", cluster.numbers[i], sep = "")
  )
  grep(ls(), pattern = "^cd3prf1pos_reclustered[0-9]", value = T)
  contrasts <- do.call(cbind, lapply(grep(ls(), pattern = "cd3prf1pos_reclustered[0-9]", value = T), get))
  colnames(prf1.pos.contrasts) <- grep(ls(), pattern = "cd3prf1pos_reclustered[0-9]", value = T)
}
## Conduct differential gene expression testing between CD3+ PRF1+ lymphocyte clusters
prf1.pos.glmQLFTest <- list()
for (i in 1:length(colnames(prf1.pos.contrasts))) {
  prf1.pos.glmQLFTest[[i]] <- glmQLFTest(fit, contrast = contrasts[, i]) %>%
    topTags(n = NULL)
}
```

### Setting up objects/variables to plot CD3+PRF1+ analysis

```{r Setting up objects/variables to plot CD3+PRF1+ analysis}
DefaultAssay(prf1pos.int) <- "RNA"
colorSchema_ePBMC$lymphoctyes <- coalesce(colorSchema_ePBMC$`Cytotoxic lymphocytes`, colorSchema_ePBMC$`Noncytotoxic lymphocytes`)
T.cols <- colorSchema_ePBMC$lymphoctyes[as.numeric(levels(obj$order)) + 1]
colorSchema_ePBMC$`Cytotoxic lymphocytes`[is.na(colorSchema_ePBMC$`Cytotoxic lymphocytes`)] <- "grey95"
```

### Figure 5A. UMAP of initial clustering and of independent reclustering analysis for the CD3+ PRF1+ lymphocyte compartment

```{r UMAP of initial clustering and of independent reclustering analysis for the CD3+ PRF1+ lymphocyte compartment}
epbmc.global.umap <- cluster.umap.plot(
  object = ePBMC.integrated.obj,
  group.ident = "order",
  colors = colorSchema_ePBMC$`Cytotoxic lymphocytes`,
  byrow = F,
  ciclelabels = F,
  inset = F
)
epbmc.global.umap <- epbmc.global.umap +
  NoLegend() + ggtitle("") + theme(axis.title = element_blank())
epbmc.global.umap$labels$y <- ""
epbmc.global.umap$labels$x <- ""

prf1pos.int$order <- droplevels(prf1pos.int$order)
old.umap <-
  cluster.umap.plot(obj, group.ident = "order", colors = T.cols, inset = F, byrow = F) +
  NoLegend() +
  scale_x_continuous(limits = c(-2.5, 8)) +
  scale_y_continuous(limits = c(4, 14)) +
  ggtitle("")
old.umap$labels$y <- ""
old.umap$labels$x <- ""
old.umap +
  annotation_custom(ggplotGrob(epbmc.global.umap),
    xmin = -4.35, xmax = -1,
    ymin = 10, ymax = 17.15
  )

new.t.cols <- c(
  "#543e36", "#466945", "#61691a", "#795548",
  "#9E9D24", "tan4", "#593224", "#827717", "#A1887F"
)
names(new.t.cols) <- 0:8
prf1pos.int$letter_group <- chartr("012345678", "ABCDEFGHI", prf1pos.int$integrated_snn_res.0.8)
prf1pos.int$letter_group <- as.factor(prf1pos.int$letter_group)
prf1pos.int$pp_group <- paste("pp", prf1pos.int$integrated_snn_res.0.8, sep = "")
prf1pos.int$pp_group <- as.factor(prf1pos.int$pp_group)

new.umap <-
  cluster.umap.plot(prf1pos.int,
    group.ident = "pp_group",
    colors = new.t.cols,
    shape = 22,
    inset = F,
    byrow = F
  ) + NoLegend() + ggtitle("")

new.umap$labels$x <- ""
new.umap$labels$y <- ""
new.umap$layers[[2]]$aes_params$size <- 10
new.umap$layers[[3]]$aes_params$colour <- "white"
new.umap
```

### Figure 5B. Stacked bars of cell types frequencies in CD3+ PRF1+ lymphocyte compartment across horses

```{r Stacked bars of cell types frequencies in CD3+ PRF1+ lymphocyte compartment across horses}
prf1pos.int <- StashIdent(prf1pos.int, save.name = "order")
horse_freq.table <- table(prf1pos.int$Subject, prf1pos.int$order) %>% melt()
colnames(horse_freq.table) <- c("Subject", "Celltype", "Fraction_of_all_cells")
horse_freq.table$Celltype <- as.factor(horse_freq.table$Celltype)
ggplot(horse_T_freq.table, aes(
  x = Subject,
  y = Fraction_of_all_cells,
  fill = factor(Celltype, levels = as.numeric(levels(prf1pos.int)) %>% rev())
)) +
  labs(fill = "Celltype") +
  geom_bar(stat = "identity", position = "fill", width = 0.9666) +
  scale_fill_manual(values = new.t.cols) +
  theme_classic() +
  ylab(label = "Fraction of CD3+ PRF1+ lymphocytes") +
  scale_y_continuous(expand = c(0, 0)) +
  coord_flip() +
  xlab("") +
  scale_x_discrete(limits = rev(levels(horse_freq.table$Subject))) +
  guides(fill = guide_legend(ncol = 1)) +
  theme(
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 16)
  )
```

### Figure 5C. Hierarchical clustering of CD3+ PRF1+ lymphocyte clusters by RNA

```{r Hierarchical clustering of CD3+ PRF1+ lymphocyte clusters by RNA}
prf1pos.int <- NormalizeData(prf1pos.int)
prf1pos.int <- ScaleData(prf1pos.int)
prf1pos.int <- BuildClusterTree(prf1pos.int, assay = "RNA", dims = 1:30)
prf1.pos.tree <- Tool(prf1pos.int, "BuildClusterTree")
plottree(prf1pos.int)
```

### Figure 5D. Heatmap of DEGs between clusters in the CD3+ PRF1+ lymphocyte clusters

```{r Heatmap of DEGs between clusters in the CD3+ PRF1+ lymphocyte clusters}
dge_tbl <- prf1.pos.glmQLFTest
names(dge_tbl) <-
  names(dge_tbl) %>%
  strsplit(split = " ") %>%
  sapply("[[", 2) %>%
  gsub(pattern = "[^0-9.-]", replacement = "")

dge_tbl <- dge_tbl[as.numeric(jntools::get_tips_in_ape_plot_order(prf1.pos.tree)) + 1]
dge_tbl <-
  lapply(dge_tbl, tibble::remove_rownames) %>% lapply(tibble::column_to_rownames, "genes")
dge.genes <- lapply(
  dge_tbl,
  function(df) {
    df[order(df$logFC, decreasing = T), ]
  }
) %>%
  lapply(rownames) %>%
  unlist2() %>%
  unique()

flag.genes <- c(
  "GZMM", "GZMK", "GZMA",
  "TRDC", "GNLY", "KLRB1",
  "KLRF1", "ENSECAG00000006663", "ZNF683",
  "ENSECAG00000031528", "FCER1G", "CD247",
  "CD2", "CD5",
  "CD27", "CXCR3"
)

prf1.pos.hmp <- prettyheatmap(
  object = prf1pos.int,
  gene.list = dge.genes,
  text.size = 8,
  flagged_genes = flag.genes,
  downsample = 25,
  colors = new.t.cols[as.numeric(jntools::get_tips_in_ape_plot_order(prf1.pos.tree)) + 1],
  ident = "order",
  order = jntools::get_tips_in_ape_plot_order(prf1.pos.tree)
)
prf1.pos.hmp
```

### Figure 5E. Dotplot of select DEGs in CD3+ PRF1+ lymphocyte clusters

```{r Dotplot of select DEGs in CD3+ PRF1+ lymphocyte clusters}
prf1.pos.genes <- rev(c(
  "CD4", "CD8A", "ENSECAG00000000775", "ZNF683", "CD247", "FCER1G", "ENSECAG00000031528", "ENSECAG00000006663", "CD5",
  "KLRF1", "KLRB1", "GNLY", "TRDC", "CD2", "CD27", "CXCR3", "GZMM", "GZMK", "GZMA"
))
levels(prf1pos.int) <- jntools::get_tips_in_ape_plot_order(prf1.pos.tree)
seurat.dotplot <- DotPlot(prf1pos.int, features = prf1.pos.genes)

prettyDots(
  dotplot = seurat.dotplot,
  colors = new.t.cols,
  col.min = -2.5,
  col.max = 2.5
)
```

### Figure 5F. Cross-species dendrogram between human and equine CD3+PRF1+ cell type clusters identified by scRNAseq

This code requires the processed human PBMC reference dataset. This method was inspired by Zilionis R, Engblom C, Pfirschke C, Savova V, Zemmour D, Saatcioglu HD, et al. Single-Cell Transcriptomics of Human and Mouse Lung Cancers Reveals Conserved Myeloid Populations across Individuals and Species. Immunity. 2019. doi:10.1016/j.immuni.2019.03.009.

```{r Cross-species dendrogram between human and equine CD3+PRF1+ cell type clusters identified by scRNAseq}
# Human
human_pbmc <- SetIdent(human_pbmc, value = "integrated_snn_res.1.2")

dendo <- cross_species_dendrogram(species.1.obj = prf1pos.int, 
                                  species.2.obj = human_pbmc,
                                  species1.ident = NULL, 
                                  species2.ident = c(4, 17, 6, 13, 18, 20),
                                  species1.res = "pp_group", 
                                  species2.res = "human.celltype",
                                  species1.name = "horse", 
                                  species2.name = "human")

dtree <- ggtree(tr = dendo, layout = "rectangular") +
  geom_tiplab(
    align = F,
    as_ylab = T
  ) +
  theme(axis.text = element_text(size = 22))
dtree

```

## Part 7.6: CD3+ PRF1- lymphocyte analysis - Figure 6

Due to difficulty resolving T/NK cell populations (relative to other cell types) by scRNA-seq, we performed an subclustering strategy (new highly variable genes and PCs identified) to better annotate the CD3+ PRF1+ and CD3+ PRF1- lymphocyte compartments.

### Subclustering analysis of the CD3+PRF1- lymphocyte compartment

```{r Subclustering analysis of the CD3+PRF1- lymphocyte compartment}
## Subset CD3+PRF1- cell compartment/major group
ePBMC.integrated.obj <- SetIdent(ePBMC.integrated.obj, value = "final_lineage")
subset.name <- "CD3PRF1neg"
obj <- subset(ePBMC.integrated.obj, idents = subset.name)

obj.split <- SplitObject(obj, split.by = "Subject")
obj.split <- lapply(obj.split, SCTransform, vars.to.regress = "percent.mito", verbose = TRUE)
obj.features <- SelectIntegrationFeatures(object.list = obj.split, nfeatures = 5500)
immunoglobulin.genes <- c(
  grep(pattern = "^IGH", x = rownames(ePBMC.integrated.obj), value = T)[-1],
  "ENSECAG00000031522", "ENSECAG00000001923",
  "ENSECAG00000039599", "ENSECAG00000038455",
  "ENSECAG00000031094", "ENSECAG00000015109",
  "ENSECAG00000033354", "ENSECAG00000007258"
)
SelectedFeatures <- obj.features[!obj.features %in% immunoglobulin.genes]

obj.split <- PrepSCTIntegration(
  object.list = obj.split, anchor.features = SelectedFeatures,
  verbose = TRUE
)

anchors <- FindIntegrationAnchors(
  object.list = obj.split, normalization.method = "SCT",
  anchor.features = SelectedFeatures, verbose = TRUE
)

prf1neg.int <- IntegrateData(
  anchorset = anchors,
  normalization.method = "SCT",
  verbose = TRUE
)

prf1neg.int <- RunPCA(
  object = prf1neg.int,
  npcs = 100, verbose = TRUE,
  features = SelectedFeatures
)
ElbowPlot(prf1neg.int, ndims = 50)
DefaultAssay(prf1neg.int) <- "integrated"

# Set finalized number of dimensions

final.dims <- 30

# Perform clustering: Neighbor finding and resolution parameters
prf1neg.int <-
  prf1neg.int %>%
  FindNeighbors(dims = 1:final.dims) %>%
  FindClusters(algorithm = 3, resolution = c(0.8)) %>%
  RunUMAP(dims = 1:final.dims, min.dist = 0.5)

# Choose appropriate clustering resolution
res <- "integrated_snn_res.0.8"

# Choose appropriate clustering resolution
prf1neg.int <- SetIdent(object = prf1neg.int, value = res)
DefaultAssay(prf1neg.int) <- "RNA"
prf1neg.int <- NormalizeData(prf1neg.int)
prf1neg.int <- BuildClusterTree(object = prf1neg.int, dims = 1:30, assay = "RNA", reorder = T)
```

### Differential gene expressiontesting for reclustering analysis: CD3+ PRF1- lymphocyte compartment

```{r Differential gene expressiontesting for reclustering analysis: CD3+ PRF1- lymphocyte compartment}
GeneDetector(SeuratObj = prf1neg.int, threshold = 0.10, listname = "prf1.neg.marker.names")
## Filter the raw gene-cell counts matrix(stored in the Seurat object) with the gene identified above

tmp.matrix <- prf1neg.int@assays$RNA@counts[prf1.neg.marker.names, ]

## Create the Seurat object again, very important this is done because it will adjust how the nGenes are calculated.

tmp <- CreateSeuratObject(tmp.matrix)
colnames(tmp@meta.data)[3] <- "Recalculated_nGene"
tmp <- AddMetaData(object = tmp, metadata = prf1neg.int@meta.data)

## Calculate the gdr from the nGene column in the Seurat metadat

tmp@meta.data$gdr <- as.numeric(scale(tmp@meta.data$Recalculated_nGene))
tmp@meta.data$orig.ident <- NULL

## Create counts object from the edgeR package
counts <- DGEList(counts = tmp@assays$RNA@counts, genes = rownames(tmp))
## Calculate the library sizes of each single cell to be analyzed
counts$samples$lib.PBMSCize <- colSums(counts$counts)
## Calculate the normalization factors to be applied to make single cell comparable
counts <- edgeR::calcNormFactors(counts)

## Reformat metadata from the SeuratObj to make compatible with edgeR/design matrix

edgeRmetadata <- tmp@meta.data[, c("horse", "integrated_snn_res.0.8", "gdr")]
colnames(edgeRmetadata)[2] <- c("celltype")
design <- model.matrix(~ 0 + gdr + celltype + horse, data = edgeRmetadata)

## Estimate dispersion

counts <- estimateDisp(counts, design, robust = T)

## Perform the edgeR fit

fit <- glmQLFit(counts, design)

## Generate cluster contrasts for differential gene expresssion testing
cluster.numbers <- 0:16
for (i in 1:length(cluster.numbers)) {
  contrastConstructor(
    clusterIDs = cluster.numbers[i],
    clusterIDs.2 = setdiff(cluster.numbers, cluster.numbers[i]),
    design = fit.$design,
    makeContrast = T,
    name = paste("cd3prf1neg_reclustered", cluster.numbers[i], sep = "")
  )
}

grep(ls(), pattern = "^cd3prf1neg_reclustered[0-9]", value = T)
contrasts <- do.call(cbind, lapply(grep(ls(), pattern = "cd3prf1neg_reclustered[0-9]", value = T), get))
colnames(prf1.neg.contrasts) <- grep(ls(), pattern = "cd3prf1neg_reclustered[0-9]", value = T)

## Perform differential gene expression testing
prf1.neg.glmQLFTest <- list()
for (i in 1:length(colnames(prf1.neg.contrasts))) {
  prf1.pos.glmQLFTest[[i]] <- glmQLFTest(fit, contrast = contrasts[, i]) %>%
    topTags(n = NULL)
}
```

### Figure 6A. UMAP of initial clustering and of independent reclustering analysis for the CD3+ PRF1- lymphocyte compartment

```{r UMAP of initial clustering and of independent reclustering analysis for the CD3+ PRF1- lymphocyte compartment}
colorSchema_ePBMC <- read_xlsx(here("analysis/data/derived_data/colorschema_annotations.xlsx"))
colorSchema_ePBMC$lymphoctyes <- coalesce(colorSchema_ePBMC$`Cytotoxic lymphocytes`, colorSchema_ePBMC$`Noncytotoxic lymphocytes`)
T.cols <- colorSchema_ePBMC$lymphoctyes[as.numeric(levels(obj$order)) + 1]
colorSchema_ePBMC$`Noncytotoxic lymphocytes`[is.na(colorSchema_ePBMC$`Noncytotoxic lymphocytes`)] <- "grey95"

## Old, initial clustering UMAP
epbmc.global.umap <- cluster.umap.plot(
  object = ePBMC.integrated.obj,
  group.ident = "order",
  colors = colorSchema_ePBMC$`Noncytotoxic lymphocytes`,
  byrow = F,
  ciclelabels = F,
  inset = F
)
epbmc.global.umap <- epbmc.global.umap +
  NoLegend() + ggtitle("") + theme(axis.title = element_blank())
epbmc.global.umap$labels$y <- ""
epbmc.global.umap$labels$x <- ""

obj$order <- droplevels(obj$order)
old.umap <-
  cluster.umap.plot(obj,
    group.ident = "order",
    colors = colorSchema_ePBMC$lymphoctyes[as.numeric(levels(obj$order)) + 1],
    inset = F, byrow = F
  ) +
  NoLegend() +
  scale_x_continuous(limits = c(-10, 10)) +
  scale_y_continuous(limits = c(-10, 10)) +
  ggtitle("")
old.umap$labels$y <- ""
old.umap$labels$x <- ""
old.umap
old.umap$layers[[2]]$aes_params$size <- 7
old.umap$layers[[3]]$aes_params$size <- 3

old.umap +
  annotation_custom(ggplotGrob(epbmc.global.umap),
    xmin = -31, xmax = 10,
    ymin = 5.5, ymax = 13
  )

## New, independent reclusterings UMAP
prf1neg.int <- StashIdent(prf1neg.int, save.name = "order")

cd3prf1neg.colors <- c(
  "#76FF03", "coral3", "#E8F5FD", "#80DEEA", "#0288D1", "darkslategray2", "deepskyblue", "#E1F5FE",
  "#ABCD77", "#689F38", "#C8E6C9", "#E6EE9C", "#7CB342", "#4CAF50", "darkseagreen4", "darkseagreen",
  "darkolivegreen"
)

prf1neg.int$pp_group <- paste("pn", prf1neg.int$integrated_snn_res.0.8, sep = "")
prf1neg.int$pp_group <- factor(prf1neg.int$pp_group, levels = paste("pn", levels(prf1neg.int), sep = ""))

new.umap <-
  cluster.umap.plot(prf1neg.int,
    group.ident = "pp_group",
    colors = cd3prf1neg.colors,
    legend.col = 1,
    shape = 22,
    inset = F,
    byrow = F
  ) +
  ggtitle("")

new.umap <- new.umap + NoLegend()
new.umap$labels$x <- ""
new.umap$labels$y <- ""
new.umap$layers[[2]]$aes_params$size <- 8
new.umap$layers[[3]]$aes_params$size <- 2
```

### Figure 6B. Stacked bars of CD3+ PRF1- cluster frequencies across all horses

```{r Stacked bars of CD3+ PRF1- cluster frequencies across all horses}
prf1neg.int <- SetIdent(object = prf1neg.int, value = "pp_group")
prf1neg.int_4stackedbars <- subset(prf1neg.int, idents = "pn16", invert = T)
prf1neg.int_4stackedbars$order <- droplevels(prf1neg.int_4stackedbars$order)
prf1neg.int_4stackedbars$num_order <- gsub(prf1neg.int_4stackedbars$order, pattern = "pn", replacement = "") %>%
  as.numeric()

horse_freq.table <- table(prf1neg.int_4stackedbars$Subject, prf1neg.int_4stackedbars$num_order) %>% melt()
colnames(horse_freq.table) <- c("Subject", "Celltype", "Fraction_of_all_cells")
horse_freq.table$Celltype <- as.factor(horse_freq.table$Celltype)
names(cd3prf1neg.colors) <- levels(prf1neg.int$order)

ggplot(horse_freq.table, aes(
  x = Subject,
  y = Fraction_of_all_cells,
  fill = factor(Celltype, levels = 16:0)
)) +
  labs(fill = "Celltype") +
  geom_bar(stat = "identity", position = "fill", width = 0.9666) +
  scale_fill_manual(values = cd3prf1neg.colors) +
  theme_classic() +
  ylab(label = "Fraction of CD3+ PRF1- lymphocytes") +
  scale_y_continuous(expand = c(0, 0)) +
  coord_flip() +
  xlab("") +
  scale_x_discrete(limits = rev(levels(horse_freq.table$Subject))) +
  guides(fill = guide_legend(ncol = 1)) +
  NoLegend() +
  theme(
    axis.text = element_text(size = 16),
    axis.title = element_text(size = 18)
  )
```

### Figure 6C. Feature plots of select T lymphocyte markers in the CD3+ PRF1- compartment

```{r Feature plots of select T lymphocyte markers in the CD3+ PRF1- compartment}
figure6_fp <- c(
  "CD4", "CD8A", "ENSECAG00000000775", "CD200",
  "CCR7", "SELL", "LEF1", "UBAC2"
)
plots <- FeaturePlot.c(object = prf1neg.int, features = figure6_fp)
plots.m <- lapply(
  plots,
  function(x) {
    x +
      NoAxes() +
      NoLegend() +
      theme(
        plot.margin = margin(0, 0, 0, 0, unit = "in"),
        plot.title = element_text(face = "italic")
      )
  }
)
plots.m[[3]]$labels$title <- c("*CD8B")

wrap_plots(plots.m, byrow = T, nrow = 2)
```

This report was generated on `r Sys.time()` using the following computational environment and dependencies: 

```{r colophon, cache = FALSE}
# which R packages and versions?
if ("devtools" %in% installed.packages()) devtools::session_info()
```

The current Git commit details are:

```{r}
# what commit is this file at?
if ("git2r" %in% installed.packages() & git2r::in_repository(path = ".")) git2r::repository(here())
```
